# é…ç½®ç®¡ç†é¡µé¢åŸå‹

## é¡µé¢æ¦‚è¿°
é…ç½®ç®¡ç†é¡µé¢æä¾›ç³»ç»Ÿå…¨å±€é…ç½®åŠŸèƒ½ï¼ŒåŒ…æ‹¬AIæ¨¡å‹é…ç½®ã€Gitä»“åº“é…ç½®ã€çŸ¥è¯†åº“ç®¡ç†ã€Promptæ¨¡æ¿ç®¡ç†ç­‰æ ¸å¿ƒç³»ç»Ÿè®¾ç½®ï¼Œæ”¯æŒå¤šç¯å¢ƒé…ç½®å’Œç‰ˆæœ¬ç®¡ç†ã€‚

## é¡µé¢å¸ƒå±€

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                            ç³»ç»Ÿé…ç½®ç®¡ç†                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [ç¯å¢ƒé€‰æ‹©â–¼] [é…ç½®ç‰ˆæœ¬â–¼] [å¯¼å…¥é…ç½®] [å¯¼å‡ºé…ç½®] [å¤‡ä»½é…ç½®] [é…ç½®å†å²]              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚       é…ç½®åˆ†ç±»èœå•       â”‚ â”‚              é…ç½®è¯¦æƒ…åŒºåŸŸ                     â”‚ â”‚
â”‚ â”‚                         â”‚ â”‚                                               â”‚ â”‚
â”‚ â”‚ ğŸ¤– AIæ¨¡å‹é…ç½®           â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚ â”‚   â— OpenAI             â”‚ â”‚ â”‚            OpenAI æ¨¡å‹é…ç½®                 â”‚ â”‚ â”‚
â”‚ â”‚   â— Azure OpenAI       â”‚ â”‚ â”‚                                           â”‚ â”‚ â”‚
â”‚ â”‚   â— æœ¬åœ°æ¨¡å‹           â”‚ â”‚ â”‚ ğŸ”‘ API é…ç½®:                              â”‚ â”‚ â”‚
â”‚ â”‚   â— æ¨¡å‹æµ‹è¯•           â”‚ â”‚ â”‚ â€¢ API Key: [sk-****************************] â”‚ â”‚ â”‚
â”‚ â”‚                         â”‚ â”‚ â”‚ â€¢ Base URL: [https://api.openai.com/v1/] â”‚ â”‚ â”‚
â”‚ â”‚ ğŸ“ Gitä»“åº“é…ç½®          â”‚ â”‚ â”‚ â€¢ Organization: [å¯é€‰]                   â”‚ â”‚ â”‚
â”‚ â”‚   â— ä»“åº“åˆ—è¡¨           â”‚ â”‚ â”‚ â€¢ è¿æ¥çŠ¶æ€: ğŸŸ¢ å·²è¿æ¥                     â”‚ â”‚ â”‚
â”‚ â”‚   â— è®¤è¯é…ç½®           â”‚ â”‚ â”‚                                           â”‚ â”‚ â”‚
â”‚ â”‚   â— è®¿é—®æƒé™           â”‚ â”‚ â”‚ ğŸ¯ æ¨¡å‹è®¾ç½®:                              â”‚ â”‚ â”‚
â”‚ â”‚   â— åˆ†æ”¯ç­–ç•¥           â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚
â”‚ â”‚                         â”‚ â”‚ â”‚ â”‚ æ¨¡å‹åç§°     â”‚ ç”¨é€”        â”‚ çŠ¶æ€ â”‚ æ“ä½œ â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ ğŸ“š çŸ¥è¯†åº“ç®¡ç†           â”‚ â”‚ â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ â”‚ â”‚
â”‚ â”‚   â— çŸ¥è¯†åº“åˆ—è¡¨         â”‚ â”‚ â”‚ â”‚ gpt-4o      â”‚ ä»£ç åˆ†æ    â”‚ âœ…  â”‚ [æµ‹è¯•] â”‚ â”‚ â”‚ â”‚
â”‚ â”‚   â— å‘é‡æ•°æ®åº“         â”‚ â”‚ â”‚ â”‚ gpt-4o-mini â”‚ ä»£ç è¯„å®¡    â”‚ âœ…  â”‚ [æµ‹è¯•] â”‚ â”‚ â”‚ â”‚
â”‚ â”‚   â— ç´¢å¼•ç®¡ç†           â”‚ â”‚ â”‚ â”‚ gpt-3.5     â”‚ èŠå¤©å¯¹è¯    â”‚ âœ…  â”‚ [æµ‹è¯•] â”‚ â”‚ â”‚ â”‚
â”‚ â”‚   â— å†…å®¹åŒæ­¥           â”‚ â”‚ â”‚ â”‚ dall-e-3    â”‚ å›¾åƒç”Ÿæˆ    â”‚ âŒ  â”‚ [é…ç½®] â”‚ â”‚ â”‚ â”‚
â”‚ â”‚                         â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â”‚
â”‚ â”‚ ğŸ’¬ Promptæ¨¡æ¿           â”‚ â”‚ â”‚                                           â”‚ â”‚ â”‚
â”‚ â”‚   â— æ¨¡æ¿åˆ†ç±»           â”‚ â”‚ â”‚ âš™ï¸ é«˜çº§è®¾ç½®:                              â”‚ â”‚ â”‚
â”‚ â”‚   â— å˜é‡ç®¡ç†           â”‚ â”‚ â”‚ â€¢ è¯·æ±‚è¶…æ—¶: [30] ç§’                       â”‚ â”‚ â”‚
â”‚ â”‚   â— ç‰ˆæœ¬æ§åˆ¶           â”‚ â”‚ â”‚ â€¢ æœ€å¤§Token: [4096]                       â”‚ â”‚ â”‚
â”‚ â”‚   â— æ•ˆæœè¯„ä¼°           â”‚ â”‚ â”‚ â€¢ æ¸©åº¦å‚æ•°: [0.7]                         â”‚ â”‚ â”‚
â”‚ â”‚                         â”‚ â”‚ â”‚ â€¢ é¢‘ç‡æƒ©ç½š: [0.0]                         â”‚ â”‚ â”‚
â”‚ â”‚ ğŸ”§ ç³»ç»Ÿè®¾ç½®             â”‚ â”‚ â”‚ â€¢ å­˜åœ¨æƒ©ç½š: [0.0]                         â”‚ â”‚ â”‚
â”‚ â”‚   â— åŸºç¡€é…ç½®           â”‚ â”‚ â”‚ â€¢ å¹¶å‘é™åˆ¶: [5]                           â”‚ â”‚ â”‚
â”‚ â”‚   â— æ€§èƒ½è®¾ç½®           â”‚ â”‚ â”‚                                           â”‚ â”‚ â”‚
â”‚ â”‚   â— å®‰å…¨ç­–ç•¥           â”‚ â”‚ â”‚ ğŸ“Š ä½¿ç”¨ç»Ÿè®¡:                              â”‚ â”‚ â”‚
â”‚ â”‚   â— é€šçŸ¥é…ç½®           â”‚ â”‚ â”‚ â€¢ ä»Šæ—¥è°ƒç”¨: 1,234 æ¬¡                      â”‚ â”‚ â”‚
â”‚ â”‚                         â”‚ â”‚ â”‚ â€¢ æœ¬æœˆæ¶ˆè€—: $45.67                       â”‚ â”‚ â”‚
â”‚ â”‚ ğŸ” æƒé™ç®¡ç†             â”‚ â”‚ â”‚ â€¢ å¹³å‡å“åº”: 1.2ç§’                         â”‚ â”‚ â”‚
â”‚ â”‚   â— è§’è‰²å®šä¹‰           â”‚ â”‚ â”‚ â€¢ æˆåŠŸç‡: 98.5%                           â”‚ â”‚ â”‚
â”‚ â”‚   â— æƒé™åˆ†é…           â”‚ â”‚ â”‚                                           â”‚ â”‚ â”‚
â”‚ â”‚   â— è®¿é—®æ§åˆ¶           â”‚ â”‚ â”‚ [ä¿å­˜é…ç½®] [æµ‹è¯•è¿æ¥] [é‡ç½®é»˜è®¤å€¼]        â”‚ â”‚ â”‚
â”‚ â”‚   â— å®¡è®¡æ—¥å¿—           â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚ â”‚                         â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”‚ âš¡ æ€§èƒ½ç›‘æ§              â”‚                                                   â”‚
â”‚ â”‚   â— ç³»ç»ŸçŠ¶æ€           â”‚                                                   â”‚
â”‚ â”‚   â— èµ„æºä½¿ç”¨           â”‚                                                   â”‚
â”‚ â”‚   â— æ€§èƒ½æŒ‡æ ‡           â”‚                                                   â”‚
â”‚ â”‚   â— æŠ¥è­¦è®¾ç½®           â”‚                                                   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## æ•°æ®æ¨¡å‹

### é…ç½®ç®¡ç†æ¥å£
```typescript
interface Configuration {
  id: string
  category: ConfigCategory
  name: string
  displayName: string
  description: string
  value: any
  defaultValue: any
  type: ConfigType
  validation: ConfigValidation
  environment: Environment
  version: string
  isEncrypted: boolean
  isRequired: boolean
  isVisible: boolean
  dependencies: string[]
  lastModified: string
  modifiedBy: string
  status: ConfigStatus
}

interface AIModelConfig {
  id: string
  provider: 'openai' | 'azure_openai' | 'anthropic' | 'local' | 'custom'
  name: string
  displayName: string
  apiKey: string
  baseUrl: string
  organization?: string
  models: ModelSetting[]
  timeout: number
  maxTokens: number
  temperature: number
  frequencyPenalty: number
  presencePenalty: number
  concurrencyLimit: number
  rateLimitPerMinute: number
  status: 'active' | 'inactive' | 'testing'
  health: HealthStatus
  usage: UsageStatistics
  lastTested: string
  testResults: TestResult[]
}

interface ModelSetting {
  modelName: string
  purpose: 'chat' | 'completion' | 'embedding' | 'image' | 'analysis' | 'review'
  isDefault: boolean
  maxTokens: number
  temperature: number
  enabled: boolean
  costPerToken: number
  features: string[]
}

interface GitRepositoryConfig {
  id: string
  name: string
  url: string
  provider: 'github' | 'gitlab' | 'bitbucket' | 'gitee' | 'custom'
  authType: 'token' | 'ssh' | 'oauth' | 'username_password'
  credentials: GitCredentials
  defaultBranch: string
  allowedBranches: string[]
  webhookUrl?: string
  webhookSecret?: string
  accessLevel: 'read' | 'write' | 'admin'
  isActive: boolean
  lastSync: string
  syncStatus: 'success' | 'failed' | 'syncing'
  repositories: RepositoryInfo[]
}

interface GitCredentials {
  token?: string
  username?: string
  password?: string
  sshKey?: string
  sshKeyPassphrase?: string
  oauthToken?: string
}

interface KnowledgeBaseConfig {
  id: string
  name: string
  description: string
  type: 'vector' | 'graph' | 'hybrid'
  vectorDatabase: VectorDbConfig
  indexConfig: IndexConfig
  syncSources: SyncSource[]
  contentTypes: string[]
  embeddingModel: string
  chunkSize: number
  chunkOverlap: number
  isActive: boolean
  lastIndexed: string
  documentCount: number
  vectorCount: number
  storageUsed: number
}

interface VectorDbConfig {
  provider: 'pinecone' | 'weaviate' | 'qdrant' | 'milvus' | 'local'
  endpoint: string
  apiKey?: string
  index: string
  dimension: number
  metric: 'cosine' | 'euclidean' | 'dotproduct'
  namespace?: string
}

interface PromptTemplate {
  id: string
  name: string
  category: string
  description: string
  content: string
  variables: PromptVariable[]
  version: string
  isActive: boolean
  usage: TemplateUsage
  effectiveness: TemplateEffectiveness
  author: string
  createdAt: string
  updatedAt: string
  tags: string[]
}

interface PromptVariable {
  name: string
  type: 'string' | 'number' | 'boolean' | 'array' | 'object'
  description: string
  defaultValue?: any
  required: boolean
  validation?: string
  examples: any[]
}

interface SystemConfig {
  database: DatabaseConfig
  cache: CacheConfig
  security: SecurityConfig
  notification: NotificationConfig
  performance: PerformanceConfig
  logging: LoggingConfig
  backup: BackupConfig
}

interface PermissionConfig {
  roles: Role[]
  permissions: Permission[]
  policies: AccessPolicy[]
  auditConfig: AuditConfig
}

type ConfigCategory = 'ai_model' | 'git' | 'knowledge_base' | 'prompt' | 'system' | 'permission' | 'performance'
type ConfigType = 'string' | 'number' | 'boolean' | 'array' | 'object' | 'password' | 'url' | 'email' | 'json'
type ConfigStatus = 'active' | 'inactive' | 'pending' | 'error'
type Environment = 'development' | 'testing' | 'staging' | 'production'
```

### çŠ¶æ€ç®¡ç†
```typescript
interface ConfigurationState {
  // é…ç½®æ•°æ®
  configurations: Record<ConfigCategory, Configuration[]>
  currentCategory: ConfigCategory
  currentConfig: Configuration | null
  
  // AIæ¨¡å‹é…ç½®
  aiModels: AIModelConfig[]
  currentAiModel: AIModelConfig | null
  modelTestResults: Record<string, TestResult>
  
  // Gitä»“åº“é…ç½®
  gitRepositories: GitRepositoryConfig[]
  currentGitRepo: GitRepositoryConfig | null
  
  // çŸ¥è¯†åº“é…ç½®
  knowledgeBases: KnowledgeBaseConfig[]
  currentKnowledgeBase: KnowledgeBaseConfig | null
  
  // Promptæ¨¡æ¿
  promptTemplates: PromptTemplate[]
  currentPromptTemplate: PromptTemplate | null
  promptCategories: string[]
  
  // ç³»ç»Ÿé…ç½®
  systemConfig: SystemConfig
  performanceMetrics: PerformanceMetrics
  healthStatus: HealthStatus
  
  // æƒé™é…ç½®
  permissionConfig: PermissionConfig
  
  // ç¯å¢ƒå’Œç‰ˆæœ¬
  currentEnvironment: Environment
  configVersions: ConfigVersion[]
  
  // UIçŠ¶æ€
  loading: boolean
  saving: boolean
  testing: boolean
  error: string | null
  
  // æœç´¢å’Œç­›é€‰
  searchTerm: string
  filters: {
    category: ConfigCategory[]
    status: ConfigStatus[]
    environment: Environment[]
    modified: [string, string] | null
  }
  
  // å¯¹è¯æ¡†çŠ¶æ€
  dialogs: {
    createConfig: boolean
    editConfig: boolean
    testConnection: boolean
    importConfig: boolean
    exportConfig: boolean
    configHistory: boolean
    backupManager: boolean
    permissionEditor: boolean
  }
}

interface ConfigurationActions {
  // é…ç½®ç®¡ç†
  loadConfigurations(category?: ConfigCategory): Promise<void>
  createConfiguration(config: CreateConfigRequest): Promise<void>
  updateConfiguration(id: string, updates: Partial<Configuration>): Promise<void>
  deleteConfiguration(id: string): Promise<void>
  resetConfiguration(id: string): Promise<void>
  
  // AIæ¨¡å‹é…ç½®
  loadAIModels(): Promise<void>
  createAIModel(model: CreateAIModelRequest): Promise<void>
  updateAIModel(id: string, updates: Partial<AIModelConfig>): Promise<void>
  deleteAIModel(id: string): Promise<void>
  testAIModel(id: string): Promise<TestResult>
  testAllAIModels(): Promise<TestResult[]>
  
  // Gitä»“åº“é…ç½®
  loadGitRepositories(): Promise<void>
  createGitRepository(repo: CreateGitRepoRequest): Promise<void>
  updateGitRepository(id: string, updates: Partial<GitRepositoryConfig>): Promise<void>
  deleteGitRepository(id: string): Promise<void>
  testGitConnection(id: string): Promise<TestResult>
  syncGitRepository(id: string): Promise<void>
  
  // çŸ¥è¯†åº“é…ç½®
  loadKnowledgeBases(): Promise<void>
  createKnowledgeBase(kb: CreateKnowledgeBaseRequest): Promise<void>
  updateKnowledgeBase(id: string, updates: Partial<KnowledgeBaseConfig>): Promise<void>
  deleteKnowledgeBase(id: string): Promise<void>
  rebuildIndex(id: string): Promise<void>
  
  // Promptæ¨¡æ¿ç®¡ç†
  loadPromptTemplates(): Promise<void>
  createPromptTemplate(template: CreatePromptTemplateRequest): Promise<void>
  updatePromptTemplate(id: string, updates: Partial<PromptTemplate>): Promise<void>
  deletePromptTemplate(id: string): Promise<void>
  testPromptTemplate(id: string, variables: Record<string, any>): Promise<string>
  
  // ç³»ç»Ÿé…ç½®
  loadSystemConfig(): Promise<void>
  updateSystemConfig(updates: Partial<SystemConfig>): Promise<void>
  loadPerformanceMetrics(): Promise<void>
  loadHealthStatus(): Promise<void>
  
  // æƒé™é…ç½®
  loadPermissionConfig(): Promise<void>
  updatePermissionConfig(updates: Partial<PermissionConfig>): Promise<void>
  
  // é…ç½®ç‰ˆæœ¬ç®¡ç†
  loadConfigVersions(): Promise<void>
  createConfigSnapshot(name: string, description?: string): Promise<void>
  restoreConfigVersion(versionId: string): Promise<void>
  compareConfigVersions(version1: string, version2: string): Promise<ConfigDiff>
  
  // å¯¼å…¥å¯¼å‡º
  exportConfiguration(options: ExportOptions): Promise<void>
  importConfiguration(file: File): Promise<void>
  
  // å¤‡ä»½ç®¡ç†
  createBackup(name: string): Promise<void>
  restoreBackup(backupId: string): Promise<void>
  
  // UIæ“ä½œ
  setCurrentCategory(category: ConfigCategory): void
  setCurrentConfig(config: Configuration | null): void
  updateFilters(filters: Partial<ConfigurationState['filters']>): void
  toggleDialog(dialog: keyof ConfigurationState['dialogs']): void
}
```

## é¡µé¢äº¤äº’é€»è¾‘

### AIæ¨¡å‹é…ç½®ç®¡ç†
```typescript
// åˆ›å»ºAIæ¨¡å‹é…ç½®
async function createAIModel() {
  const modelData = {
    provider: aiModelForm.provider,
    name: aiModelForm.name,
    displayName: aiModelForm.displayName,
    apiKey: aiModelForm.apiKey,
    baseUrl: aiModelForm.baseUrl,
    organization: aiModelForm.organization,
    models: aiModelForm.models,
    timeout: aiModelForm.timeout,
    maxTokens: aiModelForm.maxTokens,
    temperature: aiModelForm.temperature,
    concurrencyLimit: aiModelForm.concurrencyLimit
  }
  
  await configStore.createAIModel(modelData)
  showSuccessMessage('AIæ¨¡å‹é…ç½®åˆ›å»ºæˆåŠŸ')
  dialogs.createConfig = false
  await loadAIModels()
}

// æµ‹è¯•AIæ¨¡å‹è¿æ¥
async function testAIModel(model: AIModelConfig) {
  testing.value = true
  
  try {
    const testResult = await configStore.testAIModel(model.id)
    
    if (testResult.success) {
      showSuccessMessage(`æ¨¡å‹ ${model.name} è¿æ¥æµ‹è¯•æˆåŠŸ`)
      ElMessage.success({
        message: `å“åº”æ—¶é—´: ${testResult.responseTime}ms`,
        duration: 3000
      })
    } else {
      showErrorMessage(`æ¨¡å‹ ${model.name} è¿æ¥æµ‹è¯•å¤±è´¥: ${testResult.error}`)
    }
    
    // æ›´æ–°æµ‹è¯•ç»“æœ
    modelTestResults.value[model.id] = testResult
    
  } catch (error) {
    showErrorMessage(`æµ‹è¯•è¿æ¥æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`)
  } finally {
    testing.value = false
  }
}

// æ‰¹é‡æµ‹è¯•æ‰€æœ‰æ¨¡å‹
async function testAllAIModels() {
  const results = await configStore.testAllAIModels()
  
  const successCount = results.filter(r => r.success).length
  const totalCount = results.length
  
  if (successCount === totalCount) {
    showSuccessMessage(`æ‰€æœ‰ ${totalCount} ä¸ªæ¨¡å‹æµ‹è¯•é€šè¿‡`)
  } else {
    showWarningMessage(`${successCount}/${totalCount} ä¸ªæ¨¡å‹æµ‹è¯•é€šè¿‡`)
  }
  
  // æ˜¾ç¤ºè¯¦ç»†æµ‹è¯•æŠ¥å‘Š
  showTestReportModal(results)
}

// æ™ºèƒ½æ¨¡å‹æ¨è
function getModelRecommendations(purpose: string): ModelRecommendation[] {
  const recommendations = []
  
  switch (purpose) {
    case 'code_analysis':
      recommendations.push({
        model: 'gpt-4o',
        reason: 'æœ€å¼ºä»£ç ç†è§£èƒ½åŠ›ï¼Œé€‚åˆå¤æ‚ä»£ç åˆ†æ',
        confidence: 0.95
      })
      break
    case 'chat':
      recommendations.push({
        model: 'gpt-4o-mini',
        reason: 'æˆæœ¬æ•ˆç›Šæœ€ä½³ï¼Œå“åº”é€Ÿåº¦å¿«',
        confidence: 0.9
      })
      break
    case 'code_review':
      recommendations.push({
        model: 'gpt-4o',
        reason: 'èƒ½å¤Ÿè¯†åˆ«å¤æ‚çš„ä»£ç é—®é¢˜å’Œå®‰å…¨æ¼æ´',
        confidence: 0.93
      })
      break
  }
  
  return recommendations
}
```

### Gitä»“åº“é…ç½®ç®¡ç†
```typescript
// æ·»åŠ Gitä»“åº“
async function addGitRepository() {
  const repoData = {
    name: gitRepoForm.name,
    url: gitRepoForm.url,
    provider: gitRepoForm.provider,
    authType: gitRepoForm.authType,
    credentials: {
      token: gitRepoForm.token,
      username: gitRepoForm.username,
      password: gitRepoForm.password,
      sshKey: gitRepoForm.sshKey
    },
    defaultBranch: gitRepoForm.defaultBranch,
    allowedBranches: gitRepoForm.allowedBranches,
    accessLevel: gitRepoForm.accessLevel
  }
  
  await configStore.createGitRepository(repoData)
  showSuccessMessage('Gitä»“åº“é…ç½®æ·»åŠ æˆåŠŸ')
  dialogs.createConfig = false
  await loadGitRepositories()
}

// æµ‹è¯•Gitè¿æ¥
async function testGitConnection(repo: GitRepositoryConfig) {
  testing.value = true
  
  try {
    const testResult = await configStore.testGitConnection(repo.id)
    
    if (testResult.success) {
      showSuccessMessage(`ä»“åº“ ${repo.name} è¿æ¥æµ‹è¯•æˆåŠŸ`)
      
      // æ˜¾ç¤ºä»“åº“ä¿¡æ¯
      ElMessage.info({
        message: `åˆ†æ”¯: ${testResult.branches?.length || 0} ä¸ª`,
        duration: 2000
      })
    } else {
      showErrorMessage(`ä»“åº“ ${repo.name} è¿æ¥æµ‹è¯•å¤±è´¥: ${testResult.error}`)
    }
    
  } catch (error) {
    showErrorMessage(`æµ‹è¯•è¿æ¥æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`)
  } finally {
    testing.value = false
  }
}

// åŒæ­¥Gitä»“åº“
async function syncGitRepository(repo: GitRepositoryConfig) {
  await configStore.syncGitRepository(repo.id)
  
  showSuccessMessage(`ä»“åº“ ${repo.name} åŒæ­¥å¼€å§‹`)
  
  // å®æ—¶ç›‘æ§åŒæ­¥çŠ¶æ€
  const syncStatusCheck = setInterval(async () => {
    await loadGitRepositories()
    
    const updatedRepo = gitRepositories.value.find(r => r.id === repo.id)
    if (updatedRepo?.syncStatus !== 'syncing') {
      clearInterval(syncStatusCheck)
      
      if (updatedRepo?.syncStatus === 'success') {
        showSuccessMessage(`ä»“åº“ ${repo.name} åŒæ­¥å®Œæˆ`)
      } else {
        showErrorMessage(`ä»“åº“ ${repo.name} åŒæ­¥å¤±è´¥`)
      }
    }
  }, 3000)
}

// è‡ªåŠ¨æ£€æµ‹Gitæä¾›å•†
function detectGitProvider(url: string): string {
  if (url.includes('github.com')) return 'github'
  if (url.includes('gitlab.com')) return 'gitlab'
  if (url.includes('bitbucket.org')) return 'bitbucket'
  if (url.includes('gitee.com')) return 'gitee'
  return 'custom'
}

// éªŒè¯Git URLæ ¼å¼
function validateGitUrl(url: string): ValidationResult {
  const patterns = {
    https: /^https:\/\/[\w\.-]+\/[\w\.-]+\/[\w\.-]+\.git$/,
    ssh: /^git@[\w\.-]+:[\w\.-]+\/[\w\.-]+\.git$/
  }
  
  if (patterns.https.test(url) || patterns.ssh.test(url)) {
    return { valid: true }
  }
  
  return {
    valid: false,
    error: 'Git URLæ ¼å¼ä¸æ­£ç¡®'
  }
}
```

### çŸ¥è¯†åº“é…ç½®ç®¡ç†
```typescript
// åˆ›å»ºçŸ¥è¯†åº“
async function createKnowledgeBase() {
  const kbData = {
    name: knowledgeBaseForm.name,
    description: knowledgeBaseForm.description,
    type: knowledgeBaseForm.type,
    vectorDatabase: {
      provider: knowledgeBaseForm.vectorProvider,
      endpoint: knowledgeBaseForm.vectorEndpoint,
      apiKey: knowledgeBaseForm.vectorApiKey,
      index: knowledgeBaseForm.vectorIndex,
      dimension: knowledgeBaseForm.dimension,
      metric: knowledgeBaseForm.metric
    },
    embeddingModel: knowledgeBaseForm.embeddingModel,
    chunkSize: knowledgeBaseForm.chunkSize,
    chunkOverlap: knowledgeBaseForm.chunkOverlap,
    syncSources: knowledgeBaseForm.syncSources
  }
  
  await configStore.createKnowledgeBase(kbData)
  showSuccessMessage('çŸ¥è¯†åº“é…ç½®åˆ›å»ºæˆåŠŸ')
  dialogs.createConfig = false
  await loadKnowledgeBases()
}

// é‡å»ºçŸ¥è¯†åº“ç´¢å¼•
async function rebuildKnowledgeBaseIndex(kb: KnowledgeBaseConfig) {
  const confirmed = await showConfirmDialog({
    title: 'ç¡®è®¤é‡å»ºç´¢å¼•',
    message: `ç¡®å®šè¦é‡å»ºçŸ¥è¯†åº“ "${kb.name}" çš„ç´¢å¼•å—ï¼Ÿè¿™å¯èƒ½éœ€è¦è¾ƒé•¿æ—¶é—´ã€‚`,
    type: 'warning'
  })
  
  if (!confirmed) return
  
  await configStore.rebuildIndex(kb.id)
  
  showSuccessMessage(`çŸ¥è¯†åº“ ${kb.name} ç´¢å¼•é‡å»ºå·²å¼€å§‹`)
  
  // ç›‘æ§é‡å»ºè¿›åº¦
  const progressCheck = setInterval(async () => {
    await loadKnowledgeBases()
    
    const updatedKb = knowledgeBases.value.find(k => k.id === kb.id)
    if (updatedKb?.lastIndexed && updatedKb.lastIndexed !== kb.lastIndexed) {
      clearInterval(progressCheck)
      showSuccessMessage(`çŸ¥è¯†åº“ ${kb.name} ç´¢å¼•é‡å»ºå®Œæˆ`)
    }
  }, 5000)
}

// æ™ºèƒ½æ¨èå‘é‡ç»´åº¦
function recommendVectorDimension(embeddingModel: string): number {
  const dimensionMap = {
    'text-embedding-ada-002': 1536,
    'text-embedding-3-small': 1536,
    'text-embedding-3-large': 3072,
    'sentence-transformers': 768,
    'all-MiniLM-L6-v2': 384
  }
  
  return dimensionMap[embeddingModel] || 1536
}

// ä¼°ç®—å­˜å‚¨éœ€æ±‚
function estimateStorageRequirements(
  documentCount: number,
  averageDocSize: number,
  vectorDimension: number
): StorageEstimate {
  const textStorage = documentCount * averageDocSize
  const vectorStorage = documentCount * vectorDimension * 4 // 4 bytes per float
  const metadataStorage = documentCount * 0.5 * 1024 // ä¼°ç®—500Bå…ƒæ•°æ®
  
  const totalStorage = textStorage + vectorStorage + metadataStorage
  
  return {
    textStorage: formatBytes(textStorage),
    vectorStorage: formatBytes(vectorStorage),
    metadataStorage: formatBytes(metadataStorage),
    totalStorage: formatBytes(totalStorage),
    recommendation: totalStorage > 1024 * 1024 * 1024 ? 
      'å»ºè®®ä½¿ç”¨äº‘ç«¯å‘é‡æ•°æ®åº“' : 'å¯ä»¥ä½¿ç”¨æœ¬åœ°å­˜å‚¨'
  }
}
```

### Promptæ¨¡æ¿ç®¡ç†
```typescript
// åˆ›å»ºPromptæ¨¡æ¿
async function createPromptTemplate() {
  const templateData = {
    name: promptTemplateForm.name,
    category: promptTemplateForm.category,
    description: promptTemplateForm.description,
    content: promptTemplateForm.content,
    variables: promptTemplateForm.variables,
    tags: promptTemplateForm.tags
  }
  
  await configStore.createPromptTemplate(templateData)
  showSuccessMessage('Promptæ¨¡æ¿åˆ›å»ºæˆåŠŸ')
  dialogs.createConfig = false
  await loadPromptTemplates()
}

// æµ‹è¯•Promptæ¨¡æ¿
async function testPromptTemplate(template: PromptTemplate) {
  const testVariables = {}
  
  // æ”¶é›†æµ‹è¯•å˜é‡å€¼
  for (const variable of template.variables) {
    if (variable.required || variable.defaultValue === undefined) {
      testVariables[variable.name] = await promptForVariable(variable)
    } else {
      testVariables[variable.name] = variable.defaultValue
    }
  }
  
  testing.value = true
  
  try {
    const result = await configStore.testPromptTemplate(template.id, testVariables)
    
    showPromptTestResultModal({
      template,
      variables: testVariables,
      result,
      timestamp: new Date().toISOString()
    })
    
  } catch (error) {
    showErrorMessage(`Promptæµ‹è¯•å¤±è´¥: ${error.message}`)
  } finally {
    testing.value = false
  }
}

// æ™ºèƒ½å˜é‡æ£€æµ‹
function detectPromptVariables(content: string): PromptVariable[] {
  const variablePattern = /\{\{(\w+)\}\}/g
  const variables: PromptVariable[] = []
  let match
  
  while ((match = variablePattern.exec(content)) !== null) {
    const variableName = match[1]
    
    if (!variables.find(v => v.name === variableName)) {
      variables.push({
        name: variableName,
        type: inferVariableType(variableName),
        description: generateVariableDescription(variableName),
        required: true,
        examples: generateVariableExamples(variableName)
      })
    }
  }
  
  return variables
}

// æ¨æ–­å˜é‡ç±»å‹
function inferVariableType(variableName: string): string {
  const typePatterns = {
    number: /count|num|size|length|id$/i,
    boolean: /is|has|can|should|enable|disable$/i,
    array: /list|items|tags|options$/i
  }
  
  for (const [type, pattern] of Object.entries(typePatterns)) {
    if (pattern.test(variableName)) {
      return type
    }
  }
  
  return 'string'
}

// Promptæ•ˆæœè¯„ä¼°
function evaluatePromptEffectiveness(template: PromptTemplate): TemplateEffectiveness {
  const usage = template.usage
  
  return {
    usageCount: usage.totalUsage,
    successRate: usage.successfulRuns / usage.totalUsage,
    averageResponseTime: usage.averageResponseTime,
    userSatisfaction: usage.averageRating,
    commonIssues: usage.commonErrors.slice(0, 3),
    recommendations: generatePromptRecommendations(template)
  }
}
```

### ç³»ç»Ÿé…ç½®ç®¡ç†
```typescript
// æ›´æ–°ç³»ç»Ÿé…ç½®
async function updateSystemConfig() {
  const configData = {
    database: {
      ...systemConfigForm.database,
      connectionPool: {
        minConnections: systemConfigForm.dbMinConnections,
        maxConnections: systemConfigForm.dbMaxConnections,
        connectionTimeout: systemConfigForm.dbConnectionTimeout
      }
    },
    cache: {
      provider: systemConfigForm.cacheProvider,
      ttl: systemConfigForm.cacheTtl,
      maxSize: systemConfigForm.cacheMaxSize
    },
    security: {
      ...systemConfigForm.security,
      sessionTimeout: systemConfigForm.sessionTimeout,
      passwordPolicy: systemConfigForm.passwordPolicy
    },
    performance: {
      ...systemConfigForm.performance,
      maxConcurrentRequests: systemConfigForm.maxConcurrentRequests,
      requestTimeout: systemConfigForm.requestTimeout
    }
  }
  
  await configStore.updateSystemConfig(configData)
  showSuccessMessage('ç³»ç»Ÿé…ç½®æ›´æ–°æˆåŠŸ')
  
  // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡å¯æœåŠ¡
  if (requiresRestart(configData)) {
    showRestartWarning()
  }
}

// æ€§èƒ½ç›‘æ§
async function loadPerformanceMetrics() {
  const metrics = await configStore.loadPerformanceMetrics()
  
  performanceMetrics.value = {
    ...metrics,
    alerts: generatePerformanceAlerts(metrics)
  }
}

// ç”Ÿæˆæ€§èƒ½å‘Šè­¦
function generatePerformanceAlerts(metrics: PerformanceMetrics): Alert[] {
  const alerts: Alert[] = []
  
  if (metrics.cpuUsage > 80) {
    alerts.push({
      type: 'warning',
      message: 'CPUä½¿ç”¨ç‡è¿‡é«˜',
      recommendation: 'è€ƒè™‘å¢åŠ æœåŠ¡å™¨èµ„æºæˆ–ä¼˜åŒ–ä»£ç '
    })
  }
  
  if (metrics.memoryUsage > 85) {
    alerts.push({
      type: 'critical',
      message: 'å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜',
      recommendation: 'ç«‹å³æ£€æŸ¥å†…å­˜æ³„æ¼æˆ–å¢åŠ å†…å­˜'
    })
  }
  
  if (metrics.responseTime > 3000) {
    alerts.push({
      type: 'warning',
      message: 'å“åº”æ—¶é—´è¿‡é•¿',
      recommendation: 'æ£€æŸ¥æ•°æ®åº“æŸ¥è¯¢å’Œç½‘ç»œå»¶è¿Ÿ'
    })
  }
  
  return alerts
}

// å¥åº·æ£€æŸ¥
async function performHealthCheck(): Promise<HealthStatus> {
  const checks = [
    checkDatabaseConnection(),
    checkCacheConnection(),
    checkAIModelStatus(),
    checkGitRepositoryStatus(),
    checkKnowledgeBaseStatus()
  ]
  
  const results = await Promise.allSettled(checks)
  
  const healthStatus = {
    overall: 'healthy' as HealthLevel,
    components: results.map((result, index) => ({
      name: getComponentName(index),
      status: result.status === 'fulfilled' ? 'healthy' : 'unhealthy',
      message: result.status === 'fulfilled' ? result.value : result.reason
    }))
  }
  
  // åˆ¤æ–­æ•´ä½“å¥åº·çŠ¶æ€
  const unhealthyCount = healthStatus.components.filter(c => c.status === 'unhealthy').length
  if (unhealthyCount === 0) {
    healthStatus.overall = 'healthy'
  } else if (unhealthyCount <= 2) {
    healthStatus.overall = 'degraded'
  } else {
    healthStatus.overall = 'unhealthy'
  }
  
  return healthStatus
}
```

### é…ç½®ç‰ˆæœ¬ç®¡ç†
```typescript
// åˆ›å»ºé…ç½®å¿«ç…§
async function createConfigSnapshot() {
  const snapshotData = {
    name: snapshotForm.name,
    description: snapshotForm.description,
    environment: currentEnvironment.value,
    includeSecrets: snapshotForm.includeSecrets
  }
  
  await configStore.createConfigSnapshot(snapshotData.name, snapshotData.description)
  showSuccessMessage('é…ç½®å¿«ç…§åˆ›å»ºæˆåŠŸ')
  dialogs.backupManager = false
  await loadConfigVersions()
}

// æ¢å¤é…ç½®ç‰ˆæœ¬
async function restoreConfigVersion(version: ConfigVersion) {
  const confirmed = await showConfirmDialog({
    title: 'ç¡®è®¤æ¢å¤é…ç½®',
    message: `ç¡®å®šè¦æ¢å¤åˆ°ç‰ˆæœ¬ "${version.name}" å—ï¼Ÿå½“å‰é…ç½®å°†è¢«è¦†ç›–ã€‚`,
    type: 'warning'
  })
  
  if (!confirmed) return
  
  await configStore.restoreConfigVersion(version.id)
  showSuccessMessage(`é…ç½®å·²æ¢å¤åˆ°ç‰ˆæœ¬ ${version.name}`)
  
  // é‡æ–°åŠ è½½æ‰€æœ‰é…ç½®
  await Promise.all([
    loadConfigurations(),
    loadAIModels(),
    loadGitRepositories(),
    loadKnowledgeBases(),
    loadPromptTemplates()
  ])
}

// æ¯”è¾ƒé…ç½®ç‰ˆæœ¬
async function compareConfigVersions(version1: ConfigVersion, version2: ConfigVersion) {
  const diff = await configStore.compareConfigVersions(version1.id, version2.id)
  
  showConfigDiffModal({
    version1,
    version2,
    differences: diff.differences,
    summary: diff.summary
  })
}

// è‡ªåŠ¨å¤‡ä»½ç­–ç•¥
function setupAutoBackup() {
  const backupInterval = systemConfig.value.backup.autoBackupInterval
  
  if (backupInterval > 0) {
    setInterval(async () => {
      try {
        const timestamp = formatDate(new Date(), 'yyyy-MM-dd_HH-mm-ss')
        await configStore.createConfigSnapshot(
          `auto_backup_${timestamp}`,
          'è‡ªåŠ¨å¤‡ä»½'
        )
        
        console.log('è‡ªåŠ¨å¤‡ä»½å®Œæˆ:', timestamp)
      } catch (error) {
        console.error('è‡ªåŠ¨å¤‡ä»½å¤±è´¥:', error)
      }
    }, backupInterval * 60 * 1000) // è½¬æ¢ä¸ºæ¯«ç§’
  }
}
```

## å“åº”å¼è®¾è®¡é€‚é…

### æ¡Œé¢ç«¯å¸ƒå±€ (â‰¥1200px)
- å·¦ä¾§é…ç½®åˆ†ç±»èœå•ï¼Œå³ä¾§è¯¦æƒ…åŒºåŸŸ
- å¤šæ ‡ç­¾é¡µæ”¯æŒ
- å±•å¼€çš„é…ç½®é¡¹è¯¦æƒ…
- å®Œæ•´çš„ç»Ÿè®¡å’Œç›‘æ§é¢æ¿

### å¹³æ¿ç«¯å¸ƒå±€ (768px-1199px)
- å¯æŠ˜å çš„ä¾§è¾¹æ 
- å¡ç‰‡å¼é…ç½®é¡¹å±•ç¤º
- ç®€åŒ–çš„é…ç½®è¡¨å•
- åŸºç¡€çš„æ€§èƒ½ç›‘æ§

### ç§»åŠ¨ç«¯å¸ƒå±€ (<768px)
- å…¨å±å•æ å¸ƒå±€
- åº•éƒ¨å¯¼èˆªæ 
- åˆ†æ­¥å¼é…ç½®æµç¨‹
- ç²¾ç®€çš„é…ç½®é€‰é¡¹

```typescript
// å“åº”å¼é€‚é…
const isMobile = computed(() => screenWidth.value < 768)
const isTablet = computed(() => screenWidth.value >= 768 && screenWidth.value < 1200)
const isDesktop = computed(() => screenWidth.value >= 1200)

const configFormLayout = computed(() => ({
  labelPosition: isMobile.value ? 'top' : 'right',
  labelWidth: isMobile.value ? 'auto' : '120px',
  size: isMobile.value ? 'large' : 'default'
}))

const sidebarCollapsed = computed(() => isMobile.value || isTablet.value)
```

## æ€§èƒ½ä¼˜åŒ–

### é…ç½®ç¼“å­˜
```typescript
// é…ç½®ç¼“å­˜ç®¡ç†
const configCache = new Map<string, any>()

function getCachedConfig(key: string): any {
  return configCache.get(key)
}

function setCachedConfig(key: string, value: any): void {
  configCache.set(key, value)
  
  // è®¾ç½®è¿‡æœŸæ—¶é—´
  setTimeout(() => {
    configCache.delete(key)
  }, 5 * 60 * 1000) // 5åˆ†é’Ÿ
}

// æ™ºèƒ½é¢„åŠ è½½
async function preloadRelatedConfigs(category: ConfigCategory) {
  const relatedCategories = getRelatedCategories(category)
  
  for (const relatedCategory of relatedCategories) {
    if (!getCachedConfig(relatedCategory)) {
      loadConfigurations(relatedCategory)
    }
  }
}
```

### é…ç½®éªŒè¯ä¼˜åŒ–
```typescript
// å¼‚æ­¥é…ç½®éªŒè¯
const validateConfig = debounce(async (config: Configuration) => {
  try {
    const result = await configService.validateConfiguration(config)
    updateValidationResult(config.id, result)
  } catch (error) {
    updateValidationResult(config.id, { valid: false, error: error.message })
  }
}, 1000)

// æ‰¹é‡é…ç½®æµ‹è¯•
async function batchTestConfigurations(configs: Configuration[]) {
  const testPromises = configs.map(config => 
    configService.testConfiguration(config).catch(error => ({
      configId: config.id,
      success: false,
      error: error.message
    }))
  )
  
  const results = await Promise.allSettled(testPromises)
  return results.map((result, index) => ({
    configId: configs[index].id,
    result: result.status === 'fulfilled' ? result.value : result.reason
  }))
}
```

## å®‰å…¨è€ƒè™‘

### æ•æ„Ÿé…ç½®ä¿æŠ¤
```typescript
// é…ç½®åŠ å¯†
function encryptSensitiveConfig(value: string): string {
  // ä½¿ç”¨AESåŠ å¯†æ•æ„Ÿé…ç½®
  return CryptoJS.AES.encrypt(value, getEncryptionKey()).toString()
}

function decryptSensitiveConfig(encryptedValue: string): string {
  const bytes = CryptoJS.AES.decrypt(encryptedValue, getEncryptionKey())
  return bytes.toString(CryptoJS.enc.Utf8)
}

// é…ç½®è„±æ•æ˜¾ç¤º
function maskSensitiveValue(value: string, type: ConfigType): string {
  switch (type) {
    case 'password':
    case 'api_key':
      return value.substring(0, 4) + '*'.repeat(value.length - 8) + value.substring(value.length - 4)
    case 'url':
      if (value.includes('@')) {
        return value.replace(/\/\/[^@]+@/, '//***@')
      }
      return value
    default:
      return value
  }
}

// é…ç½®è®¿é—®å®¡è®¡
async function auditConfigAccess(
  configId: string,
  action: 'view' | 'edit' | 'delete' | 'test',
  userId: string
) {
  await auditService.log({
    resourceType: 'configuration',
    resourceId: configId,
    action,
    userId,
    timestamp: new Date().toISOString(),
    ipAddress: getClientIpAddress()
  })
}
```

### æƒé™éªŒè¯
```typescript
// é…ç½®æƒé™æ£€æŸ¥
function canAccessConfig(config: Configuration, user: User): boolean {
  // æ£€æŸ¥åŸºç¡€æƒé™
  if (!user.permissions.includes('config:read')) {
    return false
  }
  
  // æ£€æŸ¥ç¯å¢ƒæƒé™
  if (!user.environments.includes(config.environment)) {
    return false
  }
  
  // æ£€æŸ¥æ•æ„Ÿé…ç½®æƒé™
  if (config.isEncrypted && !user.permissions.includes('config:view_sensitive')) {
    return false
  }
  
  return true
}

function canModifyConfig(config: Configuration, user: User): boolean {
  return canAccessConfig(config, user) && 
         user.permissions.includes('config:write') &&
         (config.environment !== 'production' || 
          user.permissions.includes('config:write_production'))
}
``` 